{"ast":null,"code":"import _objectSpread from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/src/components/widgets/LinkWidget.tsx\";\nimport * as React from \"react\";\nimport * as _ from \"lodash\";\nimport { PointModel, BaseWidget, Toolkit } from \"storm-react-diagrams\";\nimport PathFinding from \"storm-react-diagrams/dist/@types/src/routing/PathFinding\";\nexport var DefaultLinkWidget =\n/*#__PURE__*/\nfunction (_BaseWidget) {\n  _inherits(DefaultLinkWidget, _BaseWidget);\n\n  // DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n  // only set when smart routing is active\n  function DefaultLinkWidget(props) {\n    var _this;\n\n    _classCallCheck(this, DefaultLinkWidget);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultLinkWidget).call(this, \"newLink\", props));\n    _this.refLabels = void 0;\n    _this.refPaths = void 0;\n    _this.pathFinding = void 0;\n\n    _this.addPointToLink = function (event, index) {\n      if (!event.shiftKey && !_this.props.diagramEngine.isModelLocked(_this.props.link) && _this.props.link.points.length - 1 <= _this.props.diagramEngine.getMaxNumberPointsPerLink()) {\n        var point = new PointModel(_this.props.link, _this.props.diagramEngine.getRelativeMousePoint(event));\n        point.setSelected(true);\n\n        _this.forceUpdate();\n\n        _this.props.link.addPoint(point, index);\n\n        _this.props.pointAdded(point, event);\n      }\n    };\n\n    _this.findPathAndRelativePositionToRenderLabel = function (index) {\n      // an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n      var lengths = _this.refPaths.map(function (path) {\n        return path.getTotalLength();\n      }); // calculate the point where we want to display the label\n\n\n      var labelPosition = lengths.reduce(function (previousValue, currentValue) {\n        return previousValue + currentValue;\n      }, 0) * (index / (_this.props.link.labels.length + 1)); // find the path where the label will be rendered and calculate the relative position\n\n      var pathIndex = 0;\n\n      while (pathIndex < _this.refPaths.length) {\n        if (labelPosition - lengths[pathIndex] < 0) {\n          return {\n            path: _this.refPaths[pathIndex],\n            position: labelPosition\n          };\n        } // keep searching\n\n\n        labelPosition -= lengths[pathIndex];\n        pathIndex++;\n      }\n    };\n\n    _this.calculateLabelPosition = function (label, index) {\n      if (!_this.refLabels[label.id]) {\n        // no label? nothing to do here\n        return;\n      }\n\n      var _this$findPathAndRela = _this.findPathAndRelativePositionToRenderLabel(index),\n          path = _this$findPathAndRela.path,\n          position = _this$findPathAndRela.position;\n\n      var labelDimensions = {\n        width: _this.refLabels[label.id].offsetWidth,\n        height: _this.refLabels[label.id].offsetHeight\n      };\n      var pathCentre = path.getPointAtLength(position);\n      var labelCoordinates = {\n        x: pathCentre.x - labelDimensions.width / 2 + label.offsetX,\n        y: pathCentre.y - labelDimensions.height / 2 + label.offsetY\n      };\n\n      _this.refLabels[label.id].setAttribute(\"style\", \"transform: translate(\".concat(labelCoordinates.x, \"px, \").concat(labelCoordinates.y, \"px);\"));\n    };\n\n    _this.refLabels = {};\n    _this.refPaths = [];\n    _this.state = {\n      selected: false\n    };\n\n    if (props.diagramEngine.isSmartRoutingEnabled()) {\n      _this.pathFinding = new PathFinding(_this.props.diagramEngine);\n    }\n\n    return _this;\n  }\n\n  _createClass(DefaultLinkWidget, [{\n    key: \"calculateAllLabelPosition\",\n    value: function calculateAllLabelPosition() {\n      var _this2 = this;\n\n      _.forEach(this.props.link.labels, function (label, index) {\n        _this2.calculateLabelPosition(label, index + 1);\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.props.link.labels.length > 0) {\n        window.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.link.labels.length > 0) {\n        window.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n      }\n    }\n  }, {\n    key: \"generatePoint\",\n    value: function generatePoint(pointIndex) {\n      var _this3 = this;\n\n      var x = this.props.link.points[pointIndex].x;\n      var y = this.props.link.points[pointIndex].y;\n      return React.createElement(\"g\", {\n        key: \"point-\" + this.props.link.points[pointIndex].id,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 87\n        },\n        __self: this\n      }, React.createElement(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 5,\n        className: \"point \" + this.bem(\"__point\") + (this.props.link.points[pointIndex].isSelected() ? this.bem(\"--point-selected\") : \"\"),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 88\n        },\n        __self: this\n      }), React.createElement(\"circle\", {\n        onMouseLeave: function onMouseLeave() {\n          _this3.setState({\n            selected: false\n          });\n        },\n        onMouseEnter: function onMouseEnter() {\n          _this3.setState({\n            selected: true\n          });\n        },\n        \"data-id\": this.props.link.points[pointIndex].id,\n        \"data-linkid\": this.props.link.id,\n        cx: x,\n        cy: y,\n        r: 15,\n        opacity: 0,\n        className: \"point \" + this.bem(\"__point\"),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 98\n        },\n        __self: this\n      }));\n    }\n  }, {\n    key: \"generateLabel\",\n    value: function generateLabel(label) {\n      var _this4 = this;\n\n      var canvas = this.props.diagramEngine.canvas;\n      return React.createElement(\"foreignObject\", {\n        key: label.id,\n        className: this.bem(\"__label\"),\n        width: canvas.offsetWidth,\n        height: canvas.offsetHeight,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 120\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        ref: function ref(_ref) {\n          return _this4.refLabels[label.id] = _ref;\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 126\n        },\n        __self: this\n      }, this.props.diagramEngine.getFactoryForLabel(label).generateReactWidget(this.props.diagramEngine, label)));\n    }\n  }, {\n    key: \"generateLink\",\n    value: function generateLink(path, extraProps, id) {\n      var _this5 = this;\n\n      var props = this.props;\n      var Bottom = React.cloneElement(props.diagramEngine.getFactoryForLink(this.props.link).generateLinkSegment(this.props.link, this, this.state.selected || this.props.link.isSelected(), path), {\n        ref: function ref(_ref2) {\n          return _ref2 && _this5.refPaths.push(_ref2);\n        }\n      });\n      var Top = React.cloneElement(Bottom, _objectSpread({}, extraProps, {\n        strokeLinecap: \"round\",\n        onMouseLeave: function onMouseLeave() {\n          _this5.setState({\n            selected: false\n          });\n        },\n        onMouseEnter: function onMouseEnter() {\n          _this5.setState({\n            selected: true\n          });\n        },\n        ref: null,\n        \"data-linkid\": this.props.link.getID(),\n        strokeOpacity: this.state.selected ? 0.1 : 0,\n        strokeWidth: 20,\n        onContextMenu: function onContextMenu() {\n          if (!_this5.props.diagramEngine.isModelLocked(_this5.props.link)) {\n            event.preventDefault();\n\n            _this5.props.link.remove();\n          }\n        }\n      }));\n      return React.createElement(\"g\", {\n        key: \"link-\" + id,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 172\n        },\n        __self: this\n      }, Bottom, Top);\n    }\n  }, {\n    key: \"isSmartRoutingApplicable\",\n\n    /**\n     * Smart routing is only applicable when all conditions below are true:\n     * - smart routing is set to true on the engine\n     * - current link is between two nodes (not between a node and an empty point)\n     * - no custom points exist along the line\n     */\n    value: function isSmartRoutingApplicable() {\n      var _this$props = this.props,\n          diagramEngine = _this$props.diagramEngine,\n          link = _this$props.link;\n\n      if (!diagramEngine.isSmartRoutingEnabled()) {\n        return false;\n      }\n\n      if (link.points.length !== 2) {\n        return false;\n      }\n\n      if (link.sourcePort === null || link.targetPort === null) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      var diagramEngine = this.props.diagramEngine;\n\n      if (!diagramEngine.nodesRendered) {\n        return null;\n      } //ensure id is present for all points on the path\n\n\n      var points = this.props.link.points;\n      var paths = [];\n\n      if (this.isSmartRoutingApplicable()) {\n        // first step: calculate a direct path between the points being linked\n        var directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n        var routingMatrix = diagramEngine.getRoutingMatrix(); // now we need to extract, from the routing matrix, the very first walkable points\n        // so they can be used as origin and destination of the link to be created\n\n        var smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\n        if (smartLink) {\n          var start = smartLink.start,\n              end = smartLink.end,\n              pathToStart = smartLink.pathToStart,\n              pathToEnd = smartLink.pathToEnd; // second step: calculate a path avoiding hitting other elements\n\n          var simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n          paths.push( //smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n          this.generateLink(Toolkit.generateDynamicPath(simplifiedPath), {\n            onMouseDown: function onMouseDown(event) {\n              _this6.addPointToLink(event, 1);\n            }\n          }, \"0\"));\n        }\n      } // true when smart routing was skipped or not enabled.\n      // See @link{#isSmartRoutingApplicable()}.\n\n\n      if (paths.length === 0) {\n        if (points.length === 2) {\n          var isHorizontal = Math.abs(points[0].x - points[1].x) > Math.abs(points[0].y - points[1].y);\n          var xOrY = isHorizontal ? \"x\" : \"y\"; //draw the smoothing\n          //if the points are too close, just draw a straight line\n\n          var margin = 50;\n\n          if (Math.abs(points[0].x - points[1].y) < 50) {\n            margin = 5;\n          }\n\n          var pointLeft = points[0];\n          var pointRight = points[1]; //some defensive programming to make sure the smoothing is\n          //always in the right direction\n\n          if (pointLeft.x > pointRight.x) {\n            pointLeft = points[1];\n            pointRight = points[0];\n          }\n\n          paths.push(this.generateLink(Toolkit.generateCurvePath(pointLeft, pointRight, this.props.link.curvyness), {\n            onMouseDown: function onMouseDown(event) {\n              _this6.addPointToLink(event, 1);\n            }\n          }, \"0\")); // draw the link as dangeling\n\n          if (this.props.link.targetPort === null) {\n            paths.push(this.generatePoint(1));\n          }\n        } else {\n          var _loop = function _loop(j) {\n            paths.push(_this6.generateLink(Toolkit.generateLinePath(points[j], points[j + 1]), {\n              \"data-linkid\": _this6.props.link.id,\n              \"data-point\": j,\n              onMouseDown: function onMouseDown(event) {\n                _this6.addPointToLink(event, j + 1);\n              }\n            }, j));\n          };\n\n          //draw the multiple anchors and complex line instead\n          for (var j = 0; j < points.length - 1; j++) {\n            _loop(j);\n          } //render the circles\n\n\n          for (var i = 1; i < points.length - 1; i++) {\n            paths.push(this.generatePoint(i));\n          }\n\n          if (this.props.link.targetPort === null) {\n            paths.push(this.generatePoint(points.length - 1));\n          }\n        }\n      }\n\n      this.refPaths = [];\n      return React.createElement(\"g\", Object.assign({}, this.getProps(), {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 370\n        },\n        __self: this\n      }), paths, _.map(this.props.link.labels, function (labelModel) {\n        return _this6.generateLabel(labelModel);\n      }));\n    }\n  }]);\n\n  return DefaultLinkWidget;\n}(BaseWidget);\nDefaultLinkWidget.defaultProps = {\n  color: \"black\",\n  width: 3,\n  link: null,\n  smooth: false,\n  diagramEngine: null\n};","map":{"version":3,"sources":["/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/src/components/widgets/LinkWidget.tsx"],"names":["React","_","PointModel","BaseWidget","Toolkit","PathFinding","DefaultLinkWidget","props","refLabels","refPaths","pathFinding","addPointToLink","event","index","shiftKey","diagramEngine","isModelLocked","link","points","length","getMaxNumberPointsPerLink","point","getRelativeMousePoint","setSelected","forceUpdate","addPoint","pointAdded","findPathAndRelativePositionToRenderLabel","lengths","map","path","getTotalLength","labelPosition","reduce","previousValue","currentValue","labels","pathIndex","position","calculateLabelPosition","label","id","labelDimensions","width","offsetWidth","height","offsetHeight","pathCentre","getPointAtLength","labelCoordinates","x","offsetX","y","offsetY","setAttribute","state","selected","isSmartRoutingEnabled","forEach","window","requestAnimationFrame","calculateAllLabelPosition","bind","pointIndex","bem","isSelected","setState","canvas","ref","getFactoryForLabel","generateReactWidget","extraProps","Bottom","cloneElement","getFactoryForLink","generateLinkSegment","push","Top","strokeLinecap","onMouseLeave","onMouseEnter","getID","strokeOpacity","strokeWidth","onContextMenu","preventDefault","remove","sourcePort","targetPort","nodesRendered","paths","isSmartRoutingApplicable","directPathCoords","calculateDirectPath","first","last","routingMatrix","getRoutingMatrix","smartLink","calculateLinkStartEndCoords","start","end","pathToStart","pathToEnd","simplifiedPath","calculateDynamicPath","generateLink","generateDynamicPath","onMouseDown","isHorizontal","Math","abs","xOrY","margin","pointLeft","pointRight","generateCurvePath","curvyness","generatePoint","j","generateLinePath","i","getProps","labelModel","generateLabel","defaultProps","color","smooth"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport * as _ from \"lodash\";\nimport { BaseWidgetProps, DiagramEngine, PointModel, BaseWidget, DefaultLinkFactory, Toolkit } from \"storm-react-diagrams\";\nimport { Link } from \"../models/Link\";\nimport PathFinding from \"storm-react-diagrams/dist/@types/src/routing/PathFinding\";\nimport { Label } from \"../models/Label\";\n\nexport interface DefaultLinkProps extends BaseWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: Link;\n\tdiagramEngine: DiagramEngine;\n\tpointAdded?: (point: PointModel, event: MouseEvent) => any;\n}\n\nexport interface DefaultLinkState {\n\tselected: boolean;\n}\n\nexport class DefaultLinkWidget extends BaseWidget<DefaultLinkProps, DefaultLinkState> {\n\tpublic static defaultProps: DefaultLinkProps = {\n\t\tcolor: \"black\",\n\t\twidth: 3,\n\t\tlink: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null\n\t};\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\trefPaths: SVGPathElement[];\n\n\tpathFinding: PathFinding; // only set when smart routing is active\n\n\tconstructor(props: DefaultLinkProps) {\n\t\tsuper(\"newLink\", props);\n\n\t\tthis.refLabels = {};\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\n\t\tif (props.diagramEngine.isSmartRoutingEnabled()) {\n\t\t\tthis.pathFinding = new PathFinding(this.props.diagramEngine);\n\t\t}\n\t}\n\n\tcalculateAllLabelPosition() {\n\t\t_.forEach(this.props.link.labels as Label[], (label: Label, index) => {\n\t\t\tthis.calculateLabelPosition(label, index + 1);\n\t\t});\n\t}\n\n\tcomponentDidUpdate() {\n\t\tif (this.props.link.labels.length > 0) {\n\t\t\twindow.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n\t\t}\n\t}\n\n\tcomponentDidMount() {\n\t\tif (this.props.link.labels.length > 0) {\n\t\t\twindow.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n\t\t}\n\t}\n\n\taddPointToLink = (event: MouseEvent, index: number): void => {\n\t\tif (\n\t\t\t!event.shiftKey &&\n\t\t\t!this.props.diagramEngine.isModelLocked(this.props.link) &&\n\t\t\tthis.props.link.points.length - 1 <= this.props.diagramEngine.getMaxNumberPointsPerLink()\n\t\t) {\n\t\t\tconst point = new PointModel(this.props.link, this.props.diagramEngine.getRelativeMousePoint(event));\n\t\t\tpoint.setSelected(true);\n\t\t\tthis.forceUpdate();\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.props.pointAdded(point, event);\n\t\t}\n\t};\n\n\tgeneratePoint(pointIndex: number): JSX.Element {\n\t\tlet x = this.props.link.points[pointIndex].x;\n\t\tlet y = this.props.link.points[pointIndex].y;\n\n\t\treturn (\n\t\t\t<g key={\"point-\" + this.props.link.points[pointIndex].id}>\n\t\t\t\t<circle\n\t\t\t\t\tcx={x}\n\t\t\t\t\tcy={y}\n\t\t\t\t\tr={5}\n\t\t\t\t\tclassName={\n\t\t\t\t\t\t\"point \" +\n\t\t\t\t\t\tthis.bem(\"__point\") +\n\t\t\t\t\t\t(this.props.link.points[pointIndex].isSelected() ? this.bem(\"--point-selected\") : \"\")\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<circle\n\t\t\t\t\tonMouseLeave={() => {\n\t\t\t\t\t\tthis.setState({ selected: false });\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseEnter={() => {\n\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t}}\n\t\t\t\t\tdata-id={this.props.link.points[pointIndex].id}\n\t\t\t\t\tdata-linkid={this.props.link.id}\n\t\t\t\t\tcx={x}\n\t\t\t\t\tcy={y}\n\t\t\t\t\tr={15}\n\t\t\t\t\topacity={0}\n\t\t\t\t\tclassName={\"point \" + this.bem(\"__point\")}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t);\n\t}\n\n\tgenerateLabel(label: Label) {\n\t\tconst canvas = this.props.diagramEngine.canvas as HTMLElement;\n\t\treturn (\n\t\t\t<foreignObject\n\t\t\t\tkey={label.id}\n\t\t\t\tclassName={this.bem(\"__label\")}\n\t\t\t\twidth={canvas.offsetWidth}\n\t\t\t\theight={canvas.offsetHeight}\n\t\t\t>\n\t\t\t\t<div ref={ref => (this.refLabels[label.id] = ref)}>\n\t\t\t\t\t{this.props.diagramEngine\n\t\t\t\t\t\t.getFactoryForLabel(label)\n\t\t\t\t\t\t.generateReactWidget(this.props.diagramEngine, label)}\n\t\t\t\t</div>\n\t\t\t</foreignObject>\n\t\t);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tvar props = this.props;\n\n\t\tvar Bottom = React.cloneElement(\n\t\t\t(props.diagramEngine.getFactoryForLink(this.props.link) as DefaultLinkFactory).generateLinkSegment(\n\t\t\t\tthis.props.link,\n\t\t\t\tthis,\n\t\t\t\tthis.state.selected || this.props.link.isSelected(),\n\t\t\t\tpath\n\t\t\t),\n\t\t\t{\n\t\t\t\tref: (ref: any) => ref && this.refPaths.push(ref)\n\t\t\t}\n\t\t);\n\n\t\tvar Top = React.cloneElement(Bottom, {\n\t\t\t...extraProps,\n\t\t\tstrokeLinecap: \"round\",\n\t\t\tonMouseLeave: () => {\n\t\t\t\tthis.setState({ selected: false });\n\t\t\t},\n\t\t\tonMouseEnter: () => {\n\t\t\t\tthis.setState({ selected: true });\n\t\t\t},\n\t\t\tref: null,\n\t\t\t\"data-linkid\": this.props.link.getID(),\n\t\t\tstrokeOpacity: this.state.selected ? 0.1 : 0,\n\t\t\tstrokeWidth: 20,\n\t\t\tonContextMenu: () => {\n\t\t\t\tif (!this.props.diagramEngine.isModelLocked(this.props.link)) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tthis.props.link.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn (\n\t\t\t<g key={\"link-\" + id}>\n\t\t\t\t{Bottom}\n\t\t\t\t{Top}\n\t\t\t</g>\n\t\t);\n\t}\n\n\tfindPathAndRelativePositionToRenderLabel = (index: number): { path: any; position: number } => {\n\t\t// an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n\t\tconst lengths = this.refPaths.map(path => path.getTotalLength());\n\n\t\t// calculate the point where we want to display the label\n\t\tlet labelPosition =\n\t\t\tlengths.reduce((previousValue, currentValue) => previousValue + currentValue, 0) *\n\t\t\t(index / (this.props.link.labels.length + 1));\n\n\t\t// find the path where the label will be rendered and calculate the relative position\n\t\tlet pathIndex = 0;\n\t\twhile (pathIndex < this.refPaths.length) {\n\t\t\tif (labelPosition - lengths[pathIndex] < 0) {\n\t\t\t\treturn {\n\t\t\t\t\tpath: this.refPaths[pathIndex],\n\t\t\t\t\tposition: labelPosition\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// keep searching\n\t\t\tlabelPosition -= lengths[pathIndex];\n\t\t\tpathIndex++;\n\t\t}\n\t};\n\n\tcalculateLabelPosition = (label: Label, index: number) => {\n\t\tif (!this.refLabels[label.id]) {\n\t\t\t// no label? nothing to do here\n\t\t\treturn;\n\t\t}\n\n\t\tconst { path, position } = this.findPathAndRelativePositionToRenderLabel(index);\n\n\t\tconst labelDimensions = {\n\t\t\twidth: this.refLabels[label.id].offsetWidth,\n\t\t\theight: this.refLabels[label.id].offsetHeight\n\t\t};\n\n\t\tconst pathCentre = path.getPointAtLength(position);\n\n\t\tconst labelCoordinates = {\n\t\t\tx: pathCentre.x - labelDimensions.width / 2 + label.offsetX,\n\t\t\ty: pathCentre.y - labelDimensions.height / 2 + label.offsetY\n\t\t};\n\t\tthis.refLabels[label.id].setAttribute(\n\t\t\t\"style\",\n\t\t\t`transform: translate(${labelCoordinates.x}px, ${labelCoordinates.y}px);`\n\t\t);\n\t};\n\n\t/**\n\t * Smart routing is only applicable when all conditions below are true:\n\t * - smart routing is set to true on the engine\n\t * - current link is between two nodes (not between a node and an empty point)\n\t * - no custom points exist along the line\n\t */\n\tisSmartRoutingApplicable(): boolean {\n\t\tconst { diagramEngine, link } = this.props;\n\n\t\tif (!diagramEngine.isSmartRoutingEnabled()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (link.points.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (link.sourcePort === null || link.targetPort === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\trender() {\n\t\tconst { diagramEngine } = this.props;\n\t\tif (!diagramEngine.nodesRendered) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.points;\n\t\tvar paths = [];\n\n\t\tif (this.isSmartRoutingApplicable()) {\n\t\t\t// first step: calculate a direct path between the points being linked\n\t\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n\n\t\t\tconst routingMatrix = diagramEngine.getRoutingMatrix();\n\t\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t\t// so they can be used as origin and destination of the link to be created\n\t\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\n\t\t\tif (smartLink) {\n\t\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t\t// second step: calculate a path avoiding hitting other elements\n\t\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(\n\t\t\t\t\troutingMatrix,\n\t\t\t\t\tstart,\n\t\t\t\t\tend,\n\t\t\t\t\tpathToStart,\n\t\t\t\t\tpathToEnd\n\t\t\t\t);\n\n\t\t\t\tpaths.push(\n\t\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\tToolkit.generateDynamicPath(simplifiedPath),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tonMouseDown: (event:any) => {\n\t\t\t\t\t\t\t\tthis.addPointToLink(event, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"0\"\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// true when smart routing was skipped or not enabled.\n\t\t// See @link{#isSmartRoutingApplicable()}.\n\t\tif (paths.length === 0) {\n\t\t\tif (points.length === 2) {\n\t\t\t\tvar isHorizontal = Math.abs(points[0].x - points[1].x) > Math.abs(points[0].y - points[1].y);\n\t\t\t\tvar xOrY = isHorizontal ? \"x\" : \"y\";\n\n\t\t\t\t//draw the smoothing\n\t\t\t\t//if the points are too close, just draw a straight line\n\t\t\t\tvar margin = 50;\n\t\t\t\tif (Math.abs(points[0].x - points[1].y) < 50) {\n\t\t\t\t\tmargin = 5;\n\t\t\t\t}\n\n\t\t\t\tvar pointLeft = points[0];\n\t\t\t\tvar pointRight = points[1];\n\n\t\t\t\t//some defensive programming to make sure the smoothing is\n\t\t\t\t//always in the right direction\n\t\t\t\tif (pointLeft.x > pointRight.x) {\n\t\t\t\t\tpointLeft = points[1];\n\t\t\t\t\tpointRight = points[0];\n\t\t\t\t}\n\n\t\t\t\tpaths.push(\n\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\tToolkit.generateCurvePath(pointLeft, pointRight, this.props.link.curvyness),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tonMouseDown: (event: any) => {\n\t\t\t\t\t\t\t\tthis.addPointToLink(event, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"0\"\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// draw the link as dangeling\n\t\t\t\tif (this.props.link.targetPort === null) {\n\t\t\t\t\tpaths.push(this.generatePoint(1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//draw the multiple anchors and complex line instead\n\t\t\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\t\t\tpaths.push(\n\t\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\t\tToolkit.generateLinePath(points[j], points[j + 1]),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"data-linkid\": this.props.link.id,\n\t\t\t\t\t\t\t\t\"data-point\": j,\n\t\t\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\t\t\tthis.addPointToLink(event, j + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tj\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t//render the circles\n\t\t\t\tfor (var i = 1; i < points.length - 1; i++) {\n\t\t\t\t\tpaths.push(this.generatePoint(i));\n\t\t\t\t}\n\n\t\t\t\tif (this.props.link.targetPort === null) {\n\t\t\t\t\tpaths.push(this.generatePoint(points.length - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\treturn (\n\t\t\t<g {...this.getProps()}>\n\t\t\t\t{paths}\n\t\t\t\t{_.map(this.props.link.labels, (labelModel: Label) => {\n\t\t\t\t\treturn this.generateLabel(labelModel);\n\t\t\t\t})}\n\t\t\t</g>\n\t\t);\n\t}\n}"]},"metadata":{},"sourceType":"module"}