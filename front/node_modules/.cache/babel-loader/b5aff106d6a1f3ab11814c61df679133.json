{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _tokenTypes = require(\"./tokenTypes\");\n\nvar _tokenTypes2 = _interopRequireDefault(_tokenTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar INLINE_MAX_LENGTH = 50;\n/**\n * Bookkeeper for inline blocks.\n *\n * Inline blocks are parenthized expressions that are shorter than INLINE_MAX_LENGTH.\n * These blocks are formatted on a single line, unlike longer parenthized\n * expressions where open-parenthesis causes newline and increase of indentation.\n */\n\nvar InlineBlock = function () {\n  function InlineBlock() {\n    _classCallCheck(this, InlineBlock);\n\n    this.level = 0;\n  }\n  /**\n   * Begins inline block when lookahead through upcoming tokens determines\n   * that the block would be smaller than INLINE_MAX_LENGTH.\n   * @param  {Object[]} tokens Array of all tokens\n   * @param  {Number} index Current token position\n   */\n\n\n  InlineBlock.prototype.beginIfPossible = function beginIfPossible(tokens, index) {\n    if (this.level === 0 && this.isInlineBlock(tokens, index)) {\n      this.level = 1;\n    } else if (this.level > 0) {\n      this.level++;\n    } else {\n      this.level = 0;\n    }\n  };\n  /**\n   * Finishes current inline block.\n   * There might be several nested ones.\n   */\n\n\n  InlineBlock.prototype.end = function end() {\n    this.level--;\n  };\n  /**\n   * True when inside an inline block\n   * @return {Boolean}\n   */\n\n\n  InlineBlock.prototype.isActive = function isActive() {\n    return this.level > 0;\n  }; // Check if this should be an inline parentheses block\n  // Examples are \"NOW()\", \"COUNT(*)\", \"int(10)\", key(`somecolumn`), DECIMAL(7,2)\n\n\n  InlineBlock.prototype.isInlineBlock = function isInlineBlock(tokens, index) {\n    var length = 0;\n    var level = 0;\n\n    for (var i = index; i < tokens.length; i++) {\n      var token = tokens[i];\n      length += token.value.length; // Overran max length\n\n      if (length > INLINE_MAX_LENGTH) {\n        return false;\n      }\n\n      if (token.type === _tokenTypes2[\"default\"].OPEN_PAREN) {\n        level++;\n      } else if (token.type === _tokenTypes2[\"default\"].CLOSE_PAREN) {\n        level--;\n\n        if (level === 0) {\n          return true;\n        }\n      }\n\n      if (this.isForbiddenToken(token)) {\n        return false;\n      }\n    }\n\n    return false;\n  }; // Reserved words that cause newlines, comments and semicolons\n  // are not allowed inside inline parentheses block\n\n\n  InlineBlock.prototype.isForbiddenToken = function isForbiddenToken(_ref) {\n    var type = _ref.type,\n        value = _ref.value;\n    return type === _tokenTypes2[\"default\"].RESERVED_TOPLEVEL || type === _tokenTypes2[\"default\"].RESERVED_NEWLINE || type === _tokenTypes2[\"default\"].COMMENT || type === _tokenTypes2[\"default\"].BLOCK_COMMENT || value === \";\";\n  };\n\n  return InlineBlock;\n}();\n\nexports[\"default\"] = InlineBlock;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}