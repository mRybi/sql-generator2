{"ast":null,"code":"import _objectSpread from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/src/components/widgets/LinkWidget.tsx\";\nimport * as React from \"react\";\nimport * as _ from \"lodash\";\nimport { PointModel, BaseWidget, Toolkit } from \"storm-react-diagrams\";\nimport AppContext from \"../../context/appContext/AppContext\";\nexport var DefaultLinkWidget =\n/*#__PURE__*/\nfunction (_BaseWidget) {\n  _inherits(DefaultLinkWidget, _BaseWidget);\n\n  // DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n  // pathFinding: PathFinding; // only set when smart routing is active\n  function DefaultLinkWidget(props) {\n    var _this;\n\n    _classCallCheck(this, DefaultLinkWidget);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultLinkWidget).call(this, \"newLink\", props));\n    _this.refLabels = void 0;\n    _this.refPaths = void 0;\n\n    _this.addPointToLink = function (event, index) {\n      if (!event.shiftKey && !_this.props.diagramEngine.isModelLocked(_this.props.link) && _this.props.link.points.length - 1 <= _this.props.diagramEngine.getMaxNumberPointsPerLink()) {\n        var point = new PointModel(_this.props.link, _this.props.diagramEngine.getRelativeMousePoint(event));\n        point.setSelected(true);\n\n        _this.forceUpdate();\n\n        _this.props.link.addPoint(point, index);\n\n        _this.props.pointAdded(point, event);\n      }\n    };\n\n    _this.findPathAndRelativePositionToRenderLabel = function (index) {\n      // an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n      var lengths = _this.refPaths.map(function (path) {\n        return path.getTotalLength();\n      }); // calculate the point where we want to display the label\n\n\n      var labelPosition = lengths.reduce(function (previousValue, currentValue) {\n        return previousValue + currentValue;\n      }, 0) * (index / (_this.props.link.labels.length + 1)); // find the path where the label will be rendered and calculate the relative position\n\n      var pathIndex = 0;\n\n      while (pathIndex < _this.refPaths.length) {\n        if (labelPosition - lengths[pathIndex] < 0) {\n          return {\n            path: _this.refPaths[pathIndex],\n            position: labelPosition\n          };\n        } // keep searching\n\n\n        labelPosition -= lengths[pathIndex];\n        pathIndex++;\n      }\n\n      return null;\n    };\n\n    _this.calculateLabelPosition = function (label, index) {\n      if (!_this.refLabels[label.id]) {\n        // no label? nothing to do here\n        return;\n      }\n\n      var _this$findPathAndRela = _this.findPathAndRelativePositionToRenderLabel(index),\n          path = _this$findPathAndRela.path,\n          position = _this$findPathAndRela.position;\n\n      var labelDimensions = {\n        width: _this.refLabels[label.id].offsetWidth,\n        height: _this.refLabels[label.id].offsetHeight\n      };\n      var pathCentre = path.getPointAtLength(position);\n      var labelCoordinates = {\n        x: pathCentre.x - labelDimensions.width / 2 + label.offsetX,\n        y: pathCentre.y - labelDimensions.height / 2 + label.offsetY\n      };\n\n      _this.refLabels[label.id].setAttribute(\"style\", \"transform: translate(\".concat(labelCoordinates.x, \"px, \").concat(labelCoordinates.y, \"px);\"));\n    };\n\n    _this.refLabels = {};\n    _this.refPaths = [];\n    _this.state = {\n      selected: false\n    }; // if (props.diagramEngine.isSmartRoutingEnabled()) {\n    // \tthis.pathFinding = new PathFinding(this.props.diagramEngine);\n    // }\n\n    return _this;\n  }\n\n  _createClass(DefaultLinkWidget, [{\n    key: \"calculateAllLabelPosition\",\n    value: function calculateAllLabelPosition() {\n      var _this2 = this;\n\n      _.forEach(this.props.link.labels, function (label, index) {\n        _this2.calculateLabelPosition(label, index + 1);\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.props.link.labels.length > 0) {\n        window.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.link.labels.length > 0) {\n        window.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n      }\n    }\n  }, {\n    key: \"generatePoint\",\n    value: function generatePoint(pointIndex) {\n      var _this3 = this;\n\n      var x = this.props.link.points[pointIndex].x;\n      var y = this.props.link.points[pointIndex].y;\n      return React.createElement(\"g\", {\n        key: \"point-\" + this.props.link.points[pointIndex].id,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 92\n        },\n        __self: this\n      }, React.createElement(\"circle\", {\n        cx: x,\n        cy: y,\n        r: 5,\n        className: \"point \" + this.bem(\"__point\") + (this.props.link.points[pointIndex].isSelected() ? this.bem(\"--point-selected\") : \"\"),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 93\n        },\n        __self: this\n      }), React.createElement(\"circle\", {\n        onMouseLeave: function onMouseLeave() {\n          _this3.setState({\n            selected: false\n          });\n        },\n        onMouseEnter: function onMouseEnter() {\n          _this3.setState({\n            selected: true\n          });\n        },\n        \"data-id\": this.props.link.points[pointIndex].id,\n        \"data-linkid\": this.props.link.id,\n        cx: x,\n        cy: y,\n        r: 15,\n        opacity: 0,\n        className: \"point \" + this.bem(\"__point\"),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 103\n        },\n        __self: this\n      }));\n    }\n  }, {\n    key: \"generateLabel\",\n    value: function generateLabel(label) {\n      var _this4 = this;\n\n      var canvas = this.props.diagramEngine.canvas;\n      return React.createElement(\"foreignObject\", {\n        key: label.id,\n        className: this.bem(\"__label\"),\n        width: canvas.offsetWidth,\n        height: canvas.offsetHeight,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 125\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        ref: function ref(_ref) {\n          return _this4.refLabels[label.id] = _ref;\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 131\n        },\n        __self: this\n      }, this.props.diagramEngine.getFactoryForLabel(label).generateReactWidget(this.props.diagramEngine, label)));\n    }\n  }, {\n    key: \"generateLink\",\n    value: function generateLink(path, extraProps, id) {\n      var _this5 = this;\n\n      var props = this.props;\n      var Bottom = React.cloneElement(props.diagramEngine.getFactoryForLink(this.props.link).generateLinkSegment(this.props.link, this, this.state.selected || this.props.link.isSelected(), path), {\n        ref: function ref(_ref2) {\n          return _ref2 && _this5.refPaths.push(_ref2);\n        }\n      });\n      var Top = React.cloneElement(Bottom, _objectSpread({}, extraProps, {\n        strokeLinecap: \"round\",\n        onMouseLeave: function onMouseLeave() {\n          _this5.setState({\n            selected: false\n          });\n        },\n        onMouseEnter: function onMouseEnter() {\n          _this5.setState({\n            selected: true\n          });\n        },\n        ref: null,\n        \"data-linkid\": this.props.link.getID(),\n        strokeOpacity: this.state.selected ? 0.1 : 0,\n        strokeWidth: 20,\n        onContextMenu: function onContextMenu() {\n          if (!_this5.props.diagramEngine.isModelLocked(_this5.props.link)) {\n            event.preventDefault();\n\n            _this5.props.link.remove();\n          }\n        }\n      }));\n      return React.createElement(\"g\", {\n        key: \"link-\" + id,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 177\n        },\n        __self: this\n      }, Bottom, Top);\n    }\n  }, {\n    key: \"isSmartRoutingApplicable\",\n\n    /**\n     * Smart routing is only applicable when all conditions below are true:\n     * - smart routing is set to true on the engine\n     * - current link is between two nodes (not between a node and an empty point)\n     * - no custom points exist along the line\n     */\n    value: function isSmartRoutingApplicable() {\n      var _this$props = this.props,\n          diagramEngine = _this$props.diagramEngine,\n          link = _this$props.link;\n\n      if (!diagramEngine.isSmartRoutingEnabled()) {\n        return false;\n      }\n\n      if (link.points.length !== 2) {\n        return false;\n      }\n\n      if (link.sourcePort === null || link.targetPort === null) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      var diagramEngine = this.props.diagramEngine;\n\n      if (!diagramEngine.nodesRendered) {\n        return null;\n      } //ensure id is present for all points on the path\n\n\n      var points = this.props.link.points;\n      var paths = [];\n\n      if (this.isSmartRoutingApplicable()) {\n        // first step: calculate a direct path between the points being linked\n        // const directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n        var routingMatrix = diagramEngine.getRoutingMatrix(); // now we need to extract, from the routing matrix, the very first walkable points\n        // so they can be used as origin and destination of the link to be created\n        // const smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n        // if (smartLink) {\n        // \tconst { start, end, pathToStart, pathToEnd } = smartLink;\n        // \t// second step: calculate a path avoiding hitting other elements\n        // \tconst simplifiedPath = this.pathFinding.calculateDynamicPath(\n        // \t\troutingMatrix,\n        // \t\tstart,\n        // \t\tend,\n        // \t\tpathToStart,\n        // \t\tpathToEnd\n        // \t);\n        // \tpaths.push(\n        // \t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n        // \t\tthis.generateLink(\n        // \t\t\tToolkit.generateDynamicPath(simplifiedPath),\n        // \t\t\t{\n        // \t\t\t\tonMouseDown: (event:any) => {\n        // \t\t\t\t\tthis.addPointToLink(event, 1);\n        // \t\t\t\t}\n        // \t\t\t},\n        // \t\t\t\"0\"\n        // \t\t)\n        // \t);\n        // }\n      } // true when smart routing was skipped or not enabled.\n      // See @link{#isSmartRoutingApplicable()}.\n\n\n      if (paths.length === 0) {\n        if (points.length === 2) {\n          var isHorizontal = Math.abs(points[0].x - points[1].x) > Math.abs(points[0].y - points[1].y);\n          var xOrY = isHorizontal ? \"x\" : \"y\"; //draw the smoothing\n          //if the points are too close, just draw a straight line\n\n          var margin = 50;\n\n          if (Math.abs(points[0].y - points[1].y) < 50) {\n            margin = 5;\n          }\n\n          var pointLeft = points[0];\n          var pointRight = points[1]; //some defensive programming to make sure the smoothing is\n          //always in the right direction\n\n          if (pointLeft.x > pointRight.x) {\n            pointLeft = points[1];\n            pointRight = points[0];\n          }\n\n          paths.push(this.generateLink(Toolkit.generateCurvePath(pointLeft, pointRight, this.props.link.curvyness), {\n            onMouseDown: function onMouseDown(event) {\n              _this6.addPointToLink(event, 1);\n            }\n          }, \"0\")); // draw the link as dangeling\n\n          if (this.props.link.targetPort === null) {\n            paths.push(this.generatePoint(1));\n          }\n        } else {\n          var _loop = function _loop(j) {\n            paths.push(_this6.generateLink(Toolkit.generateLinePath(points[j], points[j + 1]), {\n              \"data-linkid\": _this6.props.link.id,\n              \"data-point\": j,\n              onMouseDown: function onMouseDown(event) {\n                _this6.addPointToLink(event, j + 1);\n              }\n            }, j));\n          };\n\n          //draw the multiple anchors and complex line instead\n          for (var j = 0; j < points.length - 1; j++) {\n            _loop(j);\n          } //render the circles\n\n\n          for (var i = 1; i < points.length - 1; i++) {\n            paths.push(this.generatePoint(i));\n          }\n\n          if (this.props.link.targetPort === null) {\n            paths.push(this.generatePoint(points.length - 1));\n          }\n        }\n      }\n\n      this.refPaths = []; // if (this.context.view === 0) {\n\n      return React.createElement(\"g\", Object.assign({}, this.getProps(), {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 377\n        },\n        __self: this\n      }), paths, _.map(this.props.link.labels, function (labelModel) {\n        return _this6.generateLabel(labelModel);\n      })); // } else {\n      // \treturn (\n      // \t\t<g {...this.getProps()}>\n      // \t\t\t{paths}\n      // \t\t\t{/* { _.map(this.props.link.labels, (labelModel: Label) => {\n      // \t\t\t\treturn this.generateLabel(labelModel);\n      // \t\t\t})} */}\n      // \t\t</g>\n      // \t);\n      // }\n    }\n  }]);\n\n  return DefaultLinkWidget;\n}(BaseWidget);\nDefaultLinkWidget.contextType = AppContext;\nDefaultLinkWidget.defaultProps = {\n  color: \"black\",\n  width: 3,\n  link: null,\n  smooth: false,\n  diagramEngine: null\n};","map":{"version":3,"sources":["/home/dell/Dokumenty/sql-gen2/sql-gen2/sql-generator2/src/components/widgets/LinkWidget.tsx"],"names":["React","_","PointModel","BaseWidget","Toolkit","AppContext","DefaultLinkWidget","props","refLabels","refPaths","addPointToLink","event","index","shiftKey","diagramEngine","isModelLocked","link","points","length","getMaxNumberPointsPerLink","point","getRelativeMousePoint","setSelected","forceUpdate","addPoint","pointAdded","findPathAndRelativePositionToRenderLabel","lengths","map","path","getTotalLength","labelPosition","reduce","previousValue","currentValue","labels","pathIndex","position","calculateLabelPosition","label","id","labelDimensions","width","offsetWidth","height","offsetHeight","pathCentre","getPointAtLength","labelCoordinates","x","offsetX","y","offsetY","setAttribute","state","selected","forEach","window","requestAnimationFrame","calculateAllLabelPosition","bind","pointIndex","bem","isSelected","setState","canvas","ref","getFactoryForLabel","generateReactWidget","extraProps","Bottom","cloneElement","getFactoryForLink","generateLinkSegment","push","Top","strokeLinecap","onMouseLeave","onMouseEnter","getID","strokeOpacity","strokeWidth","onContextMenu","preventDefault","remove","isSmartRoutingEnabled","sourcePort","targetPort","nodesRendered","paths","isSmartRoutingApplicable","routingMatrix","getRoutingMatrix","isHorizontal","Math","abs","xOrY","margin","pointLeft","pointRight","generateLink","generateCurvePath","curvyness","onMouseDown","generatePoint","j","generateLinePath","i","getProps","labelModel","generateLabel","contextType","defaultProps","color","smooth"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport * as _ from \"lodash\";\nimport { BaseWidgetProps, DiagramEngine, PointModel, BaseWidget, Toolkit } from \"storm-react-diagrams\";\nimport { Link } from \"../models/Link\";\nimport { DefaultLinkFactory } from \"../factories/DefaultLinkFactory\";\n// import PathFinding from \"storm-react-diagrams/dist/@types/src/routing/PathFinding\";\nimport { Label } from \"../models/Label\";\nimport AppContext from \"../../context/appContext/AppContext\";\n\nexport interface DefaultLinkProps extends BaseWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: Link;\n\tdiagramEngine: DiagramEngine;\n\tpointAdded?: (point: PointModel, event: MouseEvent) => any;\n}\n\nexport interface DefaultLinkState {\n\tselected: boolean;\n}\n\nexport class DefaultLinkWidget extends BaseWidget<DefaultLinkProps, DefaultLinkState> {\n\n\tstatic contextType = AppContext;\n\n\tpublic static defaultProps: DefaultLinkProps = {\n\t\tcolor: \"black\",\n\t\twidth: 3,\n\t\tlink: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null\n\t};\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\trefPaths: SVGPathElement[];\n\n\t// pathFinding: PathFinding; // only set when smart routing is active\n\n\tconstructor(props: DefaultLinkProps) {\n\t\tsuper(\"newLink\", props);\n\n\t\tthis.refLabels = {};\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\n\t\t// if (props.diagramEngine.isSmartRoutingEnabled()) {\n\t\t// \tthis.pathFinding = new PathFinding(this.props.diagramEngine);\n\t\t// }\n\t}\n\n\tcalculateAllLabelPosition() {\n\t\t_.forEach(this.props.link.labels as Label[], (label: Label, index) => {\n\t\t\tthis.calculateLabelPosition(label, index + 1);\n\t\t});\n\t}\n\n\tcomponentDidUpdate() {\n\t\tif (this.props.link.labels.length > 0) {\n\t\t\twindow.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n\t\t}\n\t}\n\n\tcomponentDidMount() {\n\t\tif (this.props.link.labels.length > 0) {\n\t\t\twindow.requestAnimationFrame(this.calculateAllLabelPosition.bind(this));\n\t\t}\n\t}\n\n\taddPointToLink = (event: MouseEvent, index: number): void => {\n\t\tif (\n\t\t\t!event.shiftKey &&\n\t\t\t!this.props.diagramEngine.isModelLocked(this.props.link) &&\n\t\t\tthis.props.link.points.length - 1 <= this.props.diagramEngine.getMaxNumberPointsPerLink()\n\t\t) {\n\t\t\tconst point = new PointModel(this.props.link, this.props.diagramEngine.getRelativeMousePoint(event));\n\t\t\tpoint.setSelected(true);\n\t\t\tthis.forceUpdate();\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.props.pointAdded(point, event);\n\t\t}\n\t};\n\n\tgeneratePoint(pointIndex: number): JSX.Element {\n\t\tlet x = this.props.link.points[pointIndex].x;\n\t\tlet y = this.props.link.points[pointIndex].y;\n\n\t\treturn (\n\t\t\t<g key={\"point-\" + this.props.link.points[pointIndex].id}>\n\t\t\t\t<circle\n\t\t\t\t\tcx={x}\n\t\t\t\t\tcy={y}\n\t\t\t\t\tr={5}\n\t\t\t\t\tclassName={\n\t\t\t\t\t\t\"point \" +\n\t\t\t\t\t\tthis.bem(\"__point\") +\n\t\t\t\t\t\t(this.props.link.points[pointIndex].isSelected() ? this.bem(\"--point-selected\") : \"\")\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<circle\n\t\t\t\t\tonMouseLeave={() => {\n\t\t\t\t\t\tthis.setState({ selected: false });\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseEnter={() => {\n\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t}}\n\t\t\t\t\tdata-id={this.props.link.points[pointIndex].id}\n\t\t\t\t\tdata-linkid={this.props.link.id}\n\t\t\t\t\tcx={x}\n\t\t\t\t\tcy={y}\n\t\t\t\t\tr={15}\n\t\t\t\t\topacity={0}\n\t\t\t\t\tclassName={\"point \" + this.bem(\"__point\")}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t);\n\t}\n\n\tgenerateLabel(label: Label) {\n\t\tconst canvas = this.props.diagramEngine.canvas as HTMLElement;\n\t\treturn (\n\t\t\t<foreignObject\n\t\t\t\tkey={label.id}\n\t\t\t\tclassName={this.bem(\"__label\")}\n\t\t\t\twidth={canvas.offsetWidth}\n\t\t\t\theight={canvas.offsetHeight}\n\t\t\t>\n\t\t\t\t<div ref={ref => (this.refLabels[label.id] = ref)}>\n\t\t\t\t\t{this.props.diagramEngine\n\t\t\t\t\t\t.getFactoryForLabel(label)\n\t\t\t\t\t\t.generateReactWidget(this.props.diagramEngine, label)}\n\t\t\t\t</div>\n\t\t\t</foreignObject>\n\t\t);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tvar props = this.props;\n\n\t\tvar Bottom = React.cloneElement(\n\t\t\t(props.diagramEngine.getFactoryForLink(this.props.link) as DefaultLinkFactory).generateLinkSegment(\n\t\t\t\tthis.props.link,\n\t\t\t\tthis,\n\t\t\t\tthis.state.selected || this.props.link.isSelected(),\n\t\t\t\tpath\n\t\t\t),\n\t\t\t{\n\t\t\t\tref: (ref: any) => ref && this.refPaths.push(ref)\n\t\t\t}\n\t\t);\n\n\t\tvar Top = React.cloneElement(Bottom, {\n\t\t\t...extraProps,\n\t\t\tstrokeLinecap: \"round\",\n\t\t\tonMouseLeave: () => {\n\t\t\t\tthis.setState({ selected: false });\n\t\t\t},\n\t\t\tonMouseEnter: () => {\n\t\t\t\tthis.setState({ selected: true });\n\t\t\t},\n\t\t\tref: null,\n\t\t\t\"data-linkid\": this.props.link.getID(),\n\t\t\tstrokeOpacity: this.state.selected ? 0.1 : 0,\n\t\t\tstrokeWidth: 20,\n\t\t\tonContextMenu: () => {\n\t\t\t\tif (!this.props.diagramEngine.isModelLocked(this.props.link)) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tthis.props.link.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn (\n\t\t\t<g key={\"link-\" + id}>\n\t\t\t\t{Bottom}\n\t\t\t\t{Top}\n\t\t\t</g>\n\t\t);\n\t}\n\n\tfindPathAndRelativePositionToRenderLabel = (index: number): { path: any; position: number } => {\n\t\t// an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n\t\tconst lengths = this.refPaths.map(path => path.getTotalLength());\n\n\t\t// calculate the point where we want to display the label\n\t\tlet labelPosition =\n\t\t\tlengths.reduce((previousValue, currentValue) => previousValue + currentValue, 0) *\n\t\t\t(index / (this.props.link.labels.length + 1));\n\n\t\t// find the path where the label will be rendered and calculate the relative position\n\t\tlet pathIndex = 0;\n\t\twhile (pathIndex < this.refPaths.length) {\n\t\t\tif (labelPosition - lengths[pathIndex] < 0) {\n\t\t\t\treturn {\n\t\t\t\t\tpath: this.refPaths[pathIndex],\n\t\t\t\t\tposition: labelPosition\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// keep searching\n\t\t\tlabelPosition -= lengths[pathIndex];\n\t\t\tpathIndex++;\n        }\n        return null;\n\t};\n\n\tcalculateLabelPosition = (label: Label, index: number) => {\n\t\tif (!this.refLabels[label.id]) {\n\t\t\t// no label? nothing to do here\n\t\t\treturn;\n\t\t}\n\n\t\tconst { path, position } = this.findPathAndRelativePositionToRenderLabel(index);\n\n\t\tconst labelDimensions = {\n\t\t\twidth: this.refLabels[label.id].offsetWidth,\n\t\t\theight: this.refLabels[label.id].offsetHeight\n\t\t};\n\n\t\tconst pathCentre = path.getPointAtLength(position);\n\n\t\tconst labelCoordinates = {\n\t\t\tx: pathCentre.x - labelDimensions.width / 2 + label.offsetX,\n\t\t\ty: pathCentre.y - labelDimensions.height / 2 + label.offsetY\n\t\t};\n\t\tthis.refLabels[label.id].setAttribute(\n\t\t\t\"style\",\n\t\t\t`transform: translate(${labelCoordinates.x}px, ${labelCoordinates.y}px);`\n\t\t);\n\t};\n\n\t/**\n\t * Smart routing is only applicable when all conditions below are true:\n\t * - smart routing is set to true on the engine\n\t * - current link is between two nodes (not between a node and an empty point)\n\t * - no custom points exist along the line\n\t */\n\tisSmartRoutingApplicable(): boolean {\n\t\tconst { diagramEngine, link } = this.props;\n\n\t\tif (!diagramEngine.isSmartRoutingEnabled()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (link.points.length !== 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (link.sourcePort === null || link.targetPort === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\trender() {\n\t\tconst { diagramEngine } = this.props;\n\t\tif (!diagramEngine.nodesRendered) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.points;\n\t\tvar paths = [];\n\n\t\tif (this.isSmartRoutingApplicable()) {\n\t\t\t// first step: calculate a direct path between the points being linked\n\t\t\t// const directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n\n\t\t\tconst routingMatrix = diagramEngine.getRoutingMatrix();\n\t\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t\t// so they can be used as origin and destination of the link to be created\n\t\t\t// const smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\n\t\t\t// if (smartLink) {\n\t\t\t// \tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t// \t// second step: calculate a path avoiding hitting other elements\n\t\t\t// \tconst simplifiedPath = this.pathFinding.calculateDynamicPath(\n\t\t\t// \t\troutingMatrix,\n\t\t\t// \t\tstart,\n\t\t\t// \t\tend,\n\t\t\t// \t\tpathToStart,\n\t\t\t// \t\tpathToEnd\n\t\t\t// \t);\n\n\t\t\t// \tpaths.push(\n\t\t\t// \t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t// \t\tthis.generateLink(\n\t\t\t// \t\t\tToolkit.generateDynamicPath(simplifiedPath),\n\t\t\t// \t\t\t{\n\t\t\t// \t\t\t\tonMouseDown: (event:any) => {\n\t\t\t// \t\t\t\t\tthis.addPointToLink(event, 1);\n\t\t\t// \t\t\t\t}\n\t\t\t// \t\t\t},\n\t\t\t// \t\t\t\"0\"\n\t\t\t// \t\t)\n\t\t\t// \t);\n\t\t\t// }\n\t\t}\n\n\t\t// true when smart routing was skipped or not enabled.\n\t\t// See @link{#isSmartRoutingApplicable()}.\n\t\tif (paths.length === 0) {\n\t\t\tif (points.length === 2) {\n\t\t\t\tvar isHorizontal = Math.abs(points[0].x - points[1].x) > Math.abs(points[0].y - points[1].y);\n\t\t\t\tvar xOrY = isHorizontal ? \"x\" : \"y\";\n\n\t\t\t\t//draw the smoothing\n\t\t\t\t//if the points are too close, just draw a straight line\n\t\t\t\tvar margin = 50;\n\t\t\t\tif (Math.abs(points[0].y - points[1].y) < 50) {\n\t\t\t\t\tmargin = 5;\n\t\t\t\t}\n\n\t\t\t\tvar pointLeft = points[0];\n\t\t\t\tvar pointRight = points[1];\n\n\t\t\t\t//some defensive programming to make sure the smoothing is\n\t\t\t\t//always in the right direction\n\t\t\t\tif (pointLeft.x > pointRight.x) {\n\t\t\t\t\tpointLeft = points[1];\n\t\t\t\t\tpointRight = points[0];\n\t\t\t\t}\n\n\t\t\t\tpaths.push(\n\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\tToolkit.generateCurvePath(pointLeft, pointRight, this.props.link.curvyness),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tonMouseDown: (event: any) => {\n\t\t\t\t\t\t\t\tthis.addPointToLink(event, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"0\"\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// draw the link as dangeling\n\t\t\t\tif (this.props.link.targetPort === null) {\n\t\t\t\t\tpaths.push(this.generatePoint(1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//draw the multiple anchors and complex line instead\n\t\t\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\t\t\tpaths.push(\n\t\t\t\t\t\tthis.generateLink(\n\t\t\t\t\t\t\tToolkit.generateLinePath(points[j], points[j + 1]),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"data-linkid\": this.props.link.id,\n\t\t\t\t\t\t\t\t\"data-point\": j,\n\t\t\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\t\t\tthis.addPointToLink(event, j + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tj\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t//render the circles\n\t\t\t\tfor (var i = 1; i < points.length - 1; i++) {\n\t\t\t\t\tpaths.push(this.generatePoint(i));\n\t\t\t\t}\n\n\t\t\t\tif (this.props.link.targetPort === null) {\n\t\t\t\t\tpaths.push(this.generatePoint(points.length - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\t// if (this.context.view === 0) {\n\t\t\treturn (\n\t\t\t\t<g {...this.getProps()}>\n\t\t\t\t\t{paths}\n\t\t\t\t\t{ _.map(this.props.link.labels, (labelModel: Label) => {\n\t\t\t\t\t\treturn this.generateLabel(labelModel);\n\t\t\t\t\t})}\n\t\t\t\t</g>\n\t\t\t);\n\t\t// } else {\n\t\t// \treturn (\n\t\t// \t\t<g {...this.getProps()}>\n\t\t// \t\t\t{paths}\n\t\t// \t\t\t{/* { _.map(this.props.link.labels, (labelModel: Label) => {\n\t\t// \t\t\t\treturn this.generateLabel(labelModel);\n\t\t// \t\t\t})} */}\n\t\t// \t\t</g>\n\t\t// \t);\n\t\t// }\n\t\t\n\t}\n}"]},"metadata":{},"sourceType":"module"}