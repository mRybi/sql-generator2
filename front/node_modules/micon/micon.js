// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Fiber, Micon, cloneOneLevelDeep, err, extend, isFunction,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  try {
    try {
      Fiber = require('synchronize').Fiber;
    } catch (_error) {
      err = _error;
      Fiber = require('fibers');
    }
  } catch (_error) {
    err = _error;
    console.warn("fibers not available!");
    Fiber = {};
  }

  isFunction = function(o) {
    return typeof o === 'function';
  };

  extend = function(a, b) {
    var k, v;
    for (k in b) {
      if (!__hasProp.call(b, k)) continue;
      v = b[k];
      a[k] = v;
    }
    return a;
  };

  cloneOneLevelDeep = function(o) {
    var v, _i, _len, _results;
    if (Array.isArray(o)) {
      _results = [];
      for (_i = 0, _len = o.length; _i < _len; _i++) {
        v = o[_i];
        _results.push(v);
      }
      return _results;
    } else {
      return extend({}, o);
    }
  };

  Micon = function() {
    this.initialize.apply(this, arguments);
    return this;
  };

  Micon.prototype.initialize = function() {
    this.name = 'app';
    return this.clear();
  };

  Micon.prototype.scope = function() {
    var callback, container, fiber, fn, list, scopeName, _i, _j, _k, _len, _len1;
    scopeName = arguments[0], container = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
    container = container[0] || {};
    if (!scopeName) {
      throw new Error("no callback for scope '" + scopeName + "'!");
    }
    if (scopeName === 'global' || scopeName === 'application' || scopeName === 'instance') {
      return callback();
    }
    if (!(fiber = Fiber.current)) {
      throw new Error("can't activate scope '" + scopeName + "' without fiber!");
    }
    if (fiber.activeScopes == null) {
      fiber.activeScopes = {};
    }
    if (scopeName in fiber.activeScopes) {
      throw new Error("scope '" + scopeName + "' already active!");
    }
    try {
      if (list = this.beforeScopeCallbacks[scopeName]) {
        for (_j = 0, _len = list.length; _j < _len; _j++) {
          fn = list[_j];
          fn();
        }
      }
      fiber.activeScopes[scopeName] = container;
      callback();
      if (list = this.afterScopeCallbacks[scopeName]) {
        for (_k = 0, _len1 = list.length; _k < _len1; _k++) {
          fn = list[_k];
          fn(container);
        }
      }
    } finally {
      delete fiber.activeScopes[scopeName];
    }
    return container;
  };

  Micon.prototype.hasScope = function(scopeName) {
    var activeScopes, _ref;
    switch (scopeName) {
      case 'application':
        return true;
      case 'global':
        return true;
      case 'fiber':
        return Fiber.current != null;
      case 'instance':
        return true;
      default:
        if (activeScopes = (_ref = Fiber.current) != null ? _ref.activeScopes : void 0) {
          return scopeName in activeScopes;
        } else {
          return false;
        }
    }
  };

  Micon.prototype.clear = function() {
    var _ref, _ref1, _ref2;
    _ref = [{}, {}], this.registry = _ref[0], this.initializers = _ref[1];
    this.applicationComponents = {};
    _ref1 = [[], []], this.beforeCallbacks = _ref1[0], this.afterCallbacks = _ref1[1];
    return _ref2 = [[], []], this.beforeScopeCallbacks = _ref2[0], this.afterScopeCallbacks = _ref2[1], _ref2;
  };

  Micon.clear = function() {
    this.activeInitializations = {};
    return this.globalComponents = {};
  };

  Micon.clear();

  Micon.prototype.clone = function(name) {
    var clone, complexObjects, k, _i, _len;
    if (name == null) {
      name = 'clone';
    }
    clone = new Micon();
    extend(clone, this);
    clone.clear();
    complexObjects = ['registry', 'initializers', 'beforeCallbacks', 'afterCallbacks', 'beforeScopeCallbacks', 'afterScopeCallbacks'];
    for (_i = 0, _len = complexObjects.length; _i < _len; _i++) {
      k = complexObjects[_i];
      clone[k] = cloneOneLevelDeep(this[k]);
    }
    for (k in clone.registry) {
      clone.inject(clone, k);
    }
    clone.name = name;
    return clone;
  };

  Micon.prototype.has = function(componentName) {
    var activeScopes, container, fiberComponents, scopeName, _ref, _ref1;
    if (!(scopeName = this.registry[componentName])) {
      return false;
    }
    switch (scopeName) {
      case 'application':
        return componentName in this.applicationComponents;
      case 'global':
        return componentName in Micon.globalComponents;
      case 'fiber':
        if (fiberComponents = (_ref = Fiber.current) != null ? _ref.fiberComponents : void 0) {
          return componentName in fiberComponents;
        } else {
          return false;
        }
        break;
      case 'instance':
        return true;
      default:
        if ((activeScopes = (_ref1 = Fiber.current) != null ? _ref1.activeScopes : void 0) && (container = activeScopes[scopeName])) {
          return componentName in container;
        } else {
          return false;
        }
    }
  };

  Micon.prototype.get = function(componentName) {
    var component, container, fiber, fiberComponents, scopeName, _ref;
    if (!(scopeName = this.registry[componentName])) {
      throw new Error("component '" + componentName + "' not registered!");
    }
    switch (scopeName) {
      case 'application':
        if (component = this.applicationComponents[componentName]) {
          return component;
        } else {
          return this._createComponent(componentName, this.applicationComponents);
        }
        break;
      case 'global':
        if (component = Micon.globalComponents[componentName]) {
          return component;
        } else {
          return this._createComponent(componentName, Micon.globalComponents);
        }
        break;
      case 'fiber':
        if (!(fiber = Fiber.current)) {
          throw new Error("can't get component '" + componentName + "', no active fiber!");
        }
        fiberComponents = (fiber.fiberComponents != null ? fiber.fiberComponents : fiber.fiberComponents = {});
        if (component = fiberComponents[componentName]) {
          return component;
        } else {
          return this._createComponent(componentName, fiberComponents);
        }
        break;
      case 'instance':
        return this._createComponent(componentName, {});
      default:
        if (!(fiber = Fiber.current)) {
          throw new Error("can't get component '" + componentName + "', no active fiber!");
        }
        if (!(container = (_ref = fiber.activeScopes) != null ? _ref[scopeName] : void 0)) {
          throw new Error("can't get component '" + componentName + "', scope '" + scopeName + "' not created!");
        }
        if (component = container[componentName]) {
          return component;
        } else {
          return this._createComponent(componentName, container);
        }
    }
  };

  Micon.prototype.set = function(componentName, component) {
    var container, fiber, fiberComponents, scopeName, _ref;
    if (!(scopeName = this.registry[componentName])) {
      throw new Error("component '" + componentName + "' not registered!");
    }
    if (!component) {
      throw new Error("can't set '" + componentName + "' component as '" + component + "'!");
    }
    component.app = this;
    switch (scopeName) {
      case 'application':
        this.applicationComponents[componentName] = component;
        this._runAfterCallbacks(componentName, component);
        return component;
      case 'global':
        Micon.globalComponents[componentName] = component;
        this._runAfterCallbacks(componentName, component);
        return component;
      case 'fiber':
        if (!(fiber = Fiber.current)) {
          throw new Error("can't get component '" + componentName + "', no active fiber!");
        }
        fiberComponents = (fiber.fiberComponents != null ? fiber.fiberComponents : fiber.fiberComponents = {});
        fiberComponents[componentName] = component;
        this._runAfterCallbacks(componentName, component);
        return component;
      case 'instance':
        throw new Error("component '" + componentName + "' has 'instance' scope, it can't be set!");
        break;
      default:
        if (!(fiber = Fiber.current)) {
          throw new Error("can't get component '" + componentName + "', no active fiber!");
        }
        if (!(container = (_ref = fiber.activeScopes) != null ? _ref[scopeName] : void 0)) {
          throw new Error("can't get component '" + componentName + "', scope '" + scopeName + "' not created!");
        }
        container[componentName] = component;
        this._runAfterCallbacks(componentName, component);
        return component;
    }
  };

  Micon.prototype.unset = function(componentName) {
    var container, fiber, fiberComponents, scopeName, _ref;
    if (!(scopeName = this.registry[componentName])) {
      throw new Error("component '" + componentName + "' not registered!");
    }
    switch (scopeName) {
      case 'application':
        return delete this.applicationComponents[componentName];
      case 'global':
        return delete Micon.globalComponents[componentName];
      case 'fiber':
        if (!(fiber = Fiber.current)) {
          throw new Error("can't get component '" + componentName + "', no active fiber!");
        }
        fiberComponents = (fiber.fiberComponents != null ? fiber.fiberComponents : fiber.fiberComponents = {});
        return delete fiberComponents[componentName];
      case 'instance':
        throw new Error("component '" + componentName + "' has 'instance' scope, it can't be unset!");
        break;
      default:
        if (!(fiber = Fiber.current)) {
          throw new Error("can't get component '" + componentName + "', no active fiber!");
        }
        if (!(container = (_ref = fiber.activeScopes) != null ? _ref[scopeName] : void 0)) {
          throw new Error("can't get component '" + componentName + "', scope '" + scopeName + "' not created!");
        }
        return delete container[componentName];
    }
  };

  Micon.prototype.register = function() {
    var args, componentName, initializer, options;
    componentName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!componentName) {
      throw new Error("can't use '" + componentName + "' as component name!");
    }
    if (args.length > 0 && isFunction(args[args.length - 1])) {
      initializer = args.pop();
    }
    options = args[0] || {};
    this.registry[componentName] = options.scope || 'application';
    this.initializers[componentName] = [initializer, options.dependencies];
    return this.inject(this, componentName);
  };

  Micon.prototype.isRegistered = function(componentName) {
    return componentName in this.registry;
  };

  Micon.prototype.before = function(componentName, callback) {
    var _base;
    return ((_base = this.beforeCallbacks)[componentName] != null ? (_base = this.beforeCallbacks)[componentName] : _base[componentName] = []).push(callback);
  };

  Micon.prototype.after = function(componentName, callback) {
    var _base;
    if (this.has(componentName)) {
      callback(this.get(componentName));
    }
    return ((_base = this.afterCallbacks)[componentName] != null ? (_base = this.afterCallbacks)[componentName] : _base[componentName] = []).push(callback);
  };

  Micon.prototype.beforeScope = function(scopeName, callback) {
    var _base;
    if (this.hasScope(scopeName)) {
      throw new Error("scope '" + scopeName + "' already created!");
    }
    return ((_base = this.beforeScopeCallbacks)[scopeName] != null ? (_base = this.beforeScopeCallbacks)[scopeName] : _base[scopeName] = []).push(callback);
  };

  Micon.prototype.afterScope = function(scopeName, callback) {
    var _base;
    if (this.hasScope(scopeName)) {
      throw new Error("scope '" + scopeName + "' already created!");
    }
    return ((_base = this.afterScopeCallbacks)[scopeName] != null ? (_base = this.afterScopeCallbacks)[scopeName] : _base[scopeName] = []).push(callback);
  };

  Micon.asynchronousInitializationTimeout = 1500;

  Micon.asynchronousInitializationInterval = 5;

  Micon.prototype._createComponent = function(componentName, container) {
    var component, dependencies, fiber, initializer, name, startTime, _i, _len, _ref;
    _ref = this.initializers[componentName], initializer = _ref[0], dependencies = _ref[1];
    if (!initializer) {
      throw new Error("no initializer for '" + componentName + "' component!");
    }
    if (fiber = Fiber.current) {
      if (fiber.activeInitializations == null) {
        fiber.activeInitializations = {};
      }
    }
    if (componentName in Micon.activeInitializations) {
      if (fiber && !(componentName in fiber.activeInitializations)) {
        startTime = Date.now();
        while (Date.now() - startTime < Micon.asynchronousInitializationTimeout) {
          setTimeout((function() {
            return fiber.run();
          }), Micon.asynchronousInitializationInterval);
          Fiber["yield"]();
          if (component = container[componentName]) {
            return component;
          }
        }
        throw new Error("failed to resolve concurrent initialization of asynchronous '" + componentName + "' component!");
      } else {
        throw new Error("component '" + componentName + "' used before its initialization finished!");
      }
    }
    if (dependencies) {
      for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
        name = dependencies[_i];
        this.get(name);
      }
    }
    if (component = container[componentName]) {
      return component;
    }
    this._runBeforeCallbacks(componentName);
    try {
      Micon.activeInitializations[componentName] = {};
      if (fiber) {
        fiber.activeInitializations[componentName] = {};
      }
      if (!(component = initializer())) {
        throw new Error("initializer for component '" + componentName + "' returns null, false or empty string!");
      }
      component.app = this;
      container[componentName] = component;
    } finally {
      delete Micon.activeInitializations[componentName];
      if (fiber) {
        delete fiber.activeInitializations[componentName];
      }
    }
    this._runAfterCallbacks(componentName, component);
    return component;
  };

  Micon.prototype.inject = function() {
    var componentName, componentNames, object, that, _i, _len, _results;
    object = arguments[0], componentNames = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    that = this;
    _results = [];
    for (_i = 0, _len = componentNames.length; _i < _len; _i++) {
      componentName = componentNames[_i];
      _results.push((function(componentName) {
        return Object.defineProperty(object, componentName, {
          get: function() {
            return that.get(componentName);
          },
          set: function(component) {
            return that.set(componentName, component);
          },
          configurable: true
        });
      })(componentName));
    }
    return _results;
  };

  Micon.prototype.inspect = function() {
    return this.name || 'app';
  };

  Micon.prototype.toString = function() {
    return this.name || 'app';
  };

  Micon.prototype._runAfterCallbacks = function(componentName, component) {
    var fn, list, _i, _len, _results;
    if (list = this.afterCallbacks[componentName]) {
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        fn = list[_i];
        _results.push(fn(component));
      }
      return _results;
    }
  };

  Micon.prototype._runBeforeCallbacks = function(componentName) {
    var fn, list, _i, _len, _results;
    if (list = this.beforeCallbacks[componentName]) {
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        fn = list[_i];
        _results.push(fn());
      }
      return _results;
    }
  };

  Micon.supportedExtensionsRe = /\.js$|\.coffee$/;

  Micon.watchInterval = 500;

  Micon.prototype.requireDirectory = function(directoryPath, options) {
    var fileName, fileNames, filePath, fs, scripts;
    if (options == null) {
      options = {};
    }
    if (!/^\//.test(directoryPath)) {
      throw new Error("path '" + directoryPath + "' should be absolute!");
    }
    directoryPath = require('path').normalize(directoryPath);
    fs = require('fs');
    fileNames = fs.readdirSync(directoryPath);
    return scripts = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = fileNames.length; _i < _len; _i++) {
        fileName = fileNames[_i];
        if (!(Micon.supportedExtensionsRe.test(fileName))) {
          continue;
        }
        if (/^app\./.test(fileName)) {
          continue;
        }
        filePath = "" + directoryPath + "/" + fileName;
        _results.push(this.requireFile(filePath, options));
      }
      return _results;
    }).call(this);
  };

  Micon.prototype.requireFile = function(filePath, options) {
    var baseFileName, baseFilePath, fileName, fileParts, fs,
      _this = this;
    if (!/^\//.test(filePath)) {
      throw new Error("path '" + filePath + "' should be absolute!");
    }
    fileParts = filePath.split('/');
    fileName = fileParts[fileParts.length - 1];
    baseFileName = fileName.replace(/\.[^\.]+$/, '');
    baseFilePath = filePath.replace(/\.[^\.]+$/, '');
    _this = this;
    _this.register(baseFileName, function() {
      _this.register(baseFileName, function() {
        return _this.applicationComponents[baseFileName];
      });
      require(baseFilePath);
      return _this.applicationComponents[baseFileName];
    });
    if (options.watch && this.environment === 'development') {
      fs = require('fs');
      return fs.watchFile(filePath, {
        interval: Micon.watchInterval
      }, function(curr, prev) {
        if (curr.mtime === prev.mtime) {
          return;
        }
        console.info("  reloading " + baseFileName);
        _this.unset(baseFileName);
        delete require.cache[filePath];
        return require(baseFilePath);
      });
    }
  };

  Object.defineProperty(Micon.prototype, 'environment', {
    get: function() {
      if (this._environmentUsed == null) {
        this._environmentUsed = true;
      }
      return this._environment != null ? this._environment : this._environment = process.env.environment || 'development';
    },
    set: function(environment) {
      if (this._environmentUsed) {
        throw new Error("can't set environment, itt's already used!");
      }
      return this._environment = environment;
    },
    configurable: true
  });

  try {
    EventEmitter = require('events').EventEmitter;
  } catch (_error) {
    err = _error;
    EventEmitter = function() {};
  }

  extend(Micon.prototype, EventEmitter.prototype);

  Micon.prototype.initializeWithoutEventEmitter = Micon.prototype.initialize;

  Micon.prototype.initialize = function() {
    this.initializeWithoutEventEmitter.apply(this, arguments);
    return EventEmitter.apply(this);
  };

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Micon;
  } else {
    window.Micon = Micon;
  }

}).call(this);
